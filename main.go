package main

import (
	"bytes"
	"flag"
	"fmt"
	"github.com/fatih/structtag"
	"github.com/google/shlex"
	"go/types"
	"golang.org/x/tools/go/packages"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"unicode"
)

type structGenFlags struct {
	OutputFile       string
	OutputPackage    string
	SourceStruct     string
	SourceStructFile string
	Tag              string
}

type typedConst string

const (
	None    typedConst = "none"
	Typed   typedConst = "typed"
	Generic typedConst = "generic"
)

var (
	out        string
	outPkg     string
	argFile    string
	argFileSet bool

	structs  = NewMultiStringValue()
	sources  = NewMultiStringValue()
	tags     = NewMultiStringValue()
	prefixes = NewMultiValue(func(s string) (*string, error) {
		if s == "none" {
			return nil, nil
		}

		return &s, nil
	})
	exports            = NewMultiBoolValue()
	includeStructs     = NewMultiBoolValue()
	includeUnexporteds = NewMultiBoolValue()
	typeds             = NewMultiValue(func(s string) (typedConst, error) {
		switch typedConst(s) {
		case None:
			return None, nil
		case Typed:
			return Typed, nil
		case Generic:
			return Generic, nil
		}

		return "", fmt.Errorf("invalid typed value: %s. Must be one of: %s, %s, %s", s, None, Typed, Generic)
	})
)

type flagValues struct {
	typed             typedConst
	includeUnexported bool
	includeStruct     bool
	export            bool
	prefix            *string
	tag               string
	source            string
	srcStruct         string
}

func main() {
	os.Setenv("GODEBUG", "gotypesalias=1")
	defer os.Unsetenv("GODEBUG")
	parseFlags()

	imports := make([][]string, len(structs.values))
	contents := make([][]byte, len(structs.values))
	for i := 0; i < len(structs.values); i++ {
		flagValues := flagValues{
			typed:             typeds.GetOrDefault(i, None),
			includeUnexported: includeUnexporteds.GetOrDefault(i, false),
			includeStruct:     includeStructs.GetOrDefault(i, false),
			export:            exports.GetOrDefault(i, false),
			prefix:            prefixes.GetOrDefault(i, nil),
			tag:               tags.GetOrDefault(i, ""),
			srcStruct:         structs.Get(i),
		}
		source, err := filepath.Abs(filepath.Dir(sources.Get(i)))
		if err != nil {
			log.Fatalf("failed: %v", err)
		}
		flagValues.source = source

		contents[i], imports[i], err = parsePackage(flagValues)
		if err != nil {
			log.Fatalf("failed to parse struct: %v", err)
		}
	}

	buf := new(bytes.Buffer)
	buf.WriteString("// Code generated by github.com/rad12000/go-sfgen; DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("// Source %s.%s:%s\n\n",
		os.Getenv("GOPACKAGE"), os.Getenv("GOFILE"), os.Getenv("GOLINE")))
	buf.WriteString(fmt.Sprintf("package %s\n", outPkg))
	seenImport := make(map[string]struct{})
	hasWrittenImportHeader := false
	for _, imports := range imports {
	InnerLoop:
		for _, imp := range imports {
			if _, ok := seenImport[imp]; ok {
				continue InnerLoop
			}

			seenImport[imp] = struct{}{}
			if !hasWrittenImportHeader {
				buf.WriteString("\nimport (\n")
				hasWrittenImportHeader = true
			}

			buf.WriteByte('"')
			buf.WriteString(imp)
			buf.WriteByte('"')
			buf.WriteByte('\n')
		}

	}
	if hasWrittenImportHeader {
		buf.WriteString(")\n")
	}

	for _, contents := range contents {
		buf.Write(contents)
		buf.WriteByte('\n')
	}

	out, err := filepath.Abs(out)
	if err != nil {
		log.Fatalf("cannot parse out filepath %v", err)
	}

	_, err = os.Stat(out)
	if err != nil {
		err = os.MkdirAll(filepath.Dir(out), os.ModeDir)
	}

	if err != nil {
		log.Fatalf("%v", err)
	}

	file, err := os.OpenFile(out, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		log.Fatalf("failed to open file at %s: %v", out, err)
	}
	defer file.Close()
	_ = file.Truncate(0)

	if _, err = file.Write(buf.Bytes()); err != nil {
		log.Fatalf("failed to write to out file %s: %v", out, err)
	}

	cmd := exec.Command("go", "fmt", out)
	if err := cmd.Run(); err != nil {
		log.Fatalf("failed to run 'go fmt %s'", out)
	}
}

func parseFlags() {
	setFlags := func(f *flag.FlagSet) {
		f.StringVar(&out, "out", "", "the output filepath")
		f.StringVar(&outPkg, "out-pkg", "", "the output package")
		f.Var(&structs, "struct", "the struct to generate field consts for")
		f.Var(&sources, "src", "the source")
		f.Var(&tags, "tag", "if provided, the name portion of the provided tag will be used")
		f.Var(&prefixes, "prefix", "if provided, this value will be prepended to the field's name")
		f.Var(&exports, "export", "if true, the generated constants will be exported")
		f.Var(&includeStructs, "include-struct", "if true, the generated constants will be prefixed with the source struct's name")
		f.Var(&includeUnexporteds, "unexported", "if true, the generated constants will include fields that are not exported on the struct")
		f.Var(&typeds, "typed", "if true, a new type with the underlying type of string is created and used for each generated const")
	}
	flag.StringVar(&argFile, "arg-file", "", "a file where several arguments live")
	setFlags(flag.CommandLine)
	flag.Parse()
	flag.Visit(func(f *flag.Flag) {
		if f.Name == "arg-file" {
			argFileSet = true
		}
	})

	if argFileSet {
		f, err := os.Open(argFile)
		if err != nil {
			log.Fatalf("cannot open arg file %q: %v", argFile, err)
		}

		defer f.Close()
		b, err := io.ReadAll(f)
		if err != nil {
			log.Fatalf("cannot read arg file %q: %v", argFile, err)
		}

		args, err := shlex.Split(strings.ReplaceAll(string(b), "\n", " "))
		if err != nil {
			log.Fatalf("cannot parse arg file %q: %v", argFile, err)
		}
		fmt.Printf("%s\n\n", strings.Join(args, ", "))

		flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ExitOnError)
		setFlags(flag.CommandLine)
		if err = flag.CommandLine.Parse(args); err != nil {
			log.Fatalf("cannot parse flags in arg file %q: %v", argFile, err)
		}
	}

	if len(structs.values) == 0 || len(sources.values) == 0 || out == "" || outPkg == "" {
		log.Fatalf("--struct, --src, --out, and --out-pkg must not be empty")
	}

	m := map[string]int{
		"--tag":            tags.Len(),
		"--export":         exports.Len(),
		"--src":            sources.Len(),
		"--prefix":         prefixes.Len(),
		"--include-struct": includeStructs.Len(),
		"--unexported":     includeUnexporteds.Len(),
		"--typed":          typeds.Len(),
	}

	sLen := len(structs.values)
	if sLen > 1 {
		hasPrintedInitialMessage := false
		for f, l := range m {
			if l < sLen {
				if !hasPrintedInitialMessage {
					log.Println("if multiple struct values are provided, all flags (except the --out and --out-pkg) must be provided for each struct")
					hasPrintedInitialMessage = true
				}

				log.Printf("missing flag %q\n", f)
			}
		}
		if hasPrintedInitialMessage {
			log.Fatal()
		}
	}
}

func parsePackage(f flagValues) (code []byte, imports []string, err error) {
	structType, s, err := loadStruct(f.source, f.srcStruct)
	if err != nil {
		return nil, nil, err
	}
	structPackage := structType.String()[:strings.LastIndexByte(structType.String(), '.')]

	var (
		buf                 bytes.Buffer
		maybeCloseConstants = func(i int) {
			if i == s.NumFields()-1 {
				buf.WriteByte(')')
			}
		}
	)

	for i := 0; i < s.NumFields(); i++ {
		field := s.Field(i)
		if !f.includeUnexported && !field.Exported() {
			maybeCloseConstants(i)
			continue
		}

		tag := s.Tag(i)
		fieldType, baseName, constName, value, imps, err := parseField(structPackage, field, tag, f)
		if err != nil {
			return nil, nil, err
		}

		if value == "-" { // Handle the case that the field is ignored
			maybeCloseConstants(i)
			continue
		}

		if f.typed == Generic {
			imports = append(imports, imps...)
		}

		bName := []rune(baseName)
		if f.export {
			bName[0] = unicode.ToUpper(bName[0])
		} else {
			bName[0] = unicode.ToLower(bName[0])
		}
		baseName = string(bName)

		if buf.Len() == 0 {
			switch f.typed {
			case Typed:
				buf.WriteString(fmt.Sprintf("type %s string\n", baseName))
				buf.WriteString(fmt.Sprintf("func (f %s) String() string { return (string)(f) }\n", baseName))
			case Generic:
				buf.WriteString(fmt.Sprintf("type %s[T any] string\n", baseName))
				buf.WriteString(fmt.Sprintf("func (f %s[T]) String() string { return (string)(f) }\n", baseName))
			}

			buf.WriteString("const (")
		} else {
			buf.WriteByte('\n')
		}

		switch f.typed {
		case Typed:
			buf.WriteString(fmt.Sprintf("%s %s = %q", constName, baseName, value))
		case Generic:
			buf.WriteString(fmt.Sprintf("%s %s[%s] = %q", constName, baseName, fieldType, value))
		default:
			buf.WriteString(fmt.Sprintf("%s = %q", constName, value))
		}
		maybeCloseConstants(i)
	}

	return buf.Bytes(), imports, nil
}

func parseField(structPackage string, field *types.Var, tag string, f flagValues) (fieldType, baseName, constName, value string, imps []string, err error) {
	tags, err := structtag.Parse(tag)
	if err != nil {
		return "", "", "", "", nil, fmt.Errorf("failed to parse struct tags for field %s: %w", field.Name(), err)
	}

	fieldType, imps = parseTypeName(structPackage, field.Type())
	tagNameValue := field.Name()

	if f.tag != "" {
		nameFromTag, err := tags.Get(f.tag)
		if err == nil && len(nameFromTag.Name) > 0 {
			tagNameValue = nameFromTag.Name
		}
	}

	tagName := strings.ToUpper(f.tag)
	if !f.includeStruct && !f.export {
		tagName = strings.ToLower(tagName)
	}

	var prefix string
	if f.prefix == nil {
		prefix = f.srcStruct + tagName
		if !f.includeStruct {
			prefix = tagName
		}

		prefix += "Field"
	} else {
		prefix = *f.prefix
	}

	cName := []rune(prefix + field.Name())
	if f.export {
		cName[0] = unicode.ToUpper(cName[0])
	} else {
		cName[0] = unicode.ToLower(cName[0])
	}

	if f.prefix != nil && !strings.Contains(prefix, "Field") {
		baseName = prefix + "Field"
	} else {
		baseName = prefix
	}

	return fieldType, baseName, string(cName), tagNameValue, imps, nil
}

func loadStruct(source, structName string) (*types.Named, *types.Struct, error) {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
	}

	p, err := packages.Load(cfg, source)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to load struct package: %w", err)
	}

	if len(p) != 1 {
		return nil, nil, fmt.Errorf("expected 1 package for %s, got %d", source, len(p))
	}

	if len(p[0].Errors) > 0 {
		return nil, nil, fmt.Errorf("%v", p[0].Errors)
	}

	scope := p[0].Types.Scope()
	if scope == nil {
		return nil, nil, fmt.Errorf("couldn't find scope: %w", err)

	}

	foundObj := scope.Lookup(structName) // *types.TypeName is returned here
	if foundObj == nil {
		return nil, nil, fmt.Errorf("type %s not found %s: %w", structName, err)
	}

	n, ok := foundObj.Type().(*types.Named)
	if !ok {
		return nil, nil, fmt.Errorf("cannot use type %s, only named struct types are supported", structName)
	}

	s, ok := n.Underlying().(*types.Struct)
	if !ok {
		return nil, nil, fmt.Errorf("cannot use type %s, only named struct types are supported", structName)
	}

	return n, s, nil
}

func parseTypeName(structPackage string, t types.Type) (fieldType string, importPath []string) {
	switch u := t.(type) {
	case *types.Basic:
		return u.Name(), nil
	case *types.Slice:
		sliceElemType, imports := parseTypeName(structPackage, u.Elem())
		return fmt.Sprintf("[]%s", sliceElemType), imports
	case *types.Array:
		arrElemType, imports := parseTypeName(structPackage, u.Elem())
		return fmt.Sprintf("[%d]%s", u.Len(), arrElemType), imports
	case *types.Chan:
		chanElemType, imports := parseTypeName(structPackage, u.Elem())
		switch u.Dir() {
		case types.SendOnly:
			return fmt.Sprintf("chan <- %s", chanElemType), imports
		case types.RecvOnly:
			return fmt.Sprintf("<-chan %s", chanElemType), imports
		case types.SendRecv:
			return fmt.Sprintf("chan %s", chanElemType), imports
		}
	case *types.Pointer:
		elemType, imports := parseTypeName(structPackage, u.Elem())
		return fmt.Sprintf("*%s", elemType), imports
	case *types.Map:
		key, keyImps := parseTypeName(structPackage, u.Key())
		val, valImps := parseTypeName(structPackage, u.Elem())
		return fmt.Sprintf("map[%s]%s", key, val), append(keyImps, valImps...)
	case *types.Signature:
		return parseTypeNameSignature(structPackage, u)
	case *types.TypeParam:
		return "any", nil
	case *types.Alias, *types.Named:
		return parseNamedType(structPackage, u)
	default:
		log.Fatalf("unhandled type %T: %s", t, t)
	}
	return "", nil
}

func parseNamedType(structPackage string, u types.Type) (string, []string) {
	name := u.String()
	dotIndex := strings.LastIndexByte(name, '.')
	pkgPath := name[:dotIndex]
	if pkgPath == structPackage {
		return name[dotIndex+1:], nil
	}

	slashIndex := strings.LastIndexByte(name, '/')
	return name[slashIndex+1:], []string{name[:dotIndex]}
}

func parseTypeNameSignature(structPackage string, u *types.Signature) (string, []string) {
	var (
		sb      strings.Builder
		imports []string
	)

	sb.WriteString("func (")
	for i := 0; i < u.Params().Len(); i++ {
		param := u.Params().At(i)
		paramType, imps := parseTypeName(structPackage, param.Type())
		imports = append(imports, imps...)
		if i > 0 && i < u.Params().Len() {
			sb.WriteByte(',')

		}
		sb.WriteString(paramType)
	}
	sb.WriteByte(')')

	if u.Results().Len() > 1 {
		sb.WriteByte('(')
	}
	for i := 0; i < u.Results().Len(); i++ {
		param := u.Results().At(i)
		paramType, imps := parseTypeName(structPackage, param.Type())
		imports = append(imports, imps...)
		if i > 0 && i < u.Results().Len() {
			sb.WriteByte(',')

		}
		sb.WriteString(paramType)
	}
	if u.Results().Len() > 1 {
		sb.WriteByte(')')
	}

	return sb.String(), imports
}
