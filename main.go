package main

import (
	"bytes"
	"flag"
	"fmt"
	"github.com/fatih/structtag"
	"go/parser"
	"go/token"
	"go/types"
	"golang.org/x/tools/go/packages"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"unicode"
)

func must[T any](t T, err error) T {
	if err != nil {
		log.Fatal(err)
	}

	return t
}

var (
	structName        string
	source            string
	out               string
	appendToOut       bool
	outPkg            string
	targetTag         string
	export            bool
	includeStructName bool
	prefix            string
	prefixSet         bool
	includeUnexported bool
	typed             bool
	genericTyped      bool
)

func main() {
	os.Setenv("GODEBUG", "gotypesalias=1")
	defer os.Unsetenv("GODEBUG")
	parseFlags()

	source, err := filepath.Abs(filepath.Dir(source))
	if err != nil {
		log.Fatalf("failed: %v", err)
	}

	contents, imports, err := parsePackage(source, structName)
	if err != nil {
		log.Fatalf("failed to parse struct: %v", err)
	}

	buf := new(bytes.Buffer)
	if appendToOut {
		buf.WriteByte('\n')
	} else {
		buf.WriteString("// Code generated by github.com/rad12000/go-sfgen; DO NOT EDIT.\n\n")
		buf.WriteString(fmt.Sprintf("package %s\n", outPkg))
		if len(imports) > 0 && genericTyped {
			buf.WriteString("\nimport (\n")
			for imp := range imports {
				buf.WriteByte('"')
				buf.WriteString(imp)
				buf.WriteByte('"')
				buf.WriteByte('\n')
			}
			buf.WriteString(")\n")
		}
	}

	buf.WriteString(fmt.Sprintf("// Source %s.%s:%s\n\n",
		os.Getenv("GOPACKAGE"), os.Getenv("GOFILE"), os.Getenv("GOLINE")))
	buf.Write(contents)

	out, err := filepath.Abs(out)
	if err != nil {
		log.Fatalf("cannot parse out filepath %v", err)
	}

	_, err = os.Stat(out)
	if err != nil {
		err = os.MkdirAll(filepath.Dir(out), os.ModeDir)
	}

	if err != nil {
		log.Fatalf("%v", err)
	}

	var file *os.File
	if appendToOut {
		file, err = os.OpenFile(out, os.O_APPEND|os.O_RDWR, 0666)
		if !genericTyped {
			imports = nil
		}
		buf2 := resolveImports(must(io.ReadAll(file)), imports)
		buf2.Write(buf.Bytes())
		buf = buf2
	} else {
		file, err = os.OpenFile(out, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	}

	if err != nil {
		log.Fatalf("failed to open file at %s: %v", out, err)
	}
	defer file.Close()
	_ = file.Truncate(0)

	if _, err = file.Write(buf.Bytes()); err != nil {
		log.Fatalf("failed to write to out file %s: %v", out, err)
	}

	cmd := exec.Command("go", "fmt", out)
	if err := cmd.Run(); err != nil {
		log.Fatalf("failed to run 'go fmt %s'", out)
	}
}

func resolveImports(srcFile []byte, imports map[string]struct{}) *bytes.Buffer {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "", srcFile, parser.ImportsOnly)
	if err != nil {
		log.Fatalf("failed to load current file %v", err)
	}

	if len(imports) == 0 {
		return bytes.NewBuffer(srcFile)
	}

	var (
		lines                 = bytes.Split(srcFile, []byte{'\n'})
		buf                   bytes.Buffer
		lineIndexAfterPackage = fset.Position(file.Package).Line
		topLines              = lines[:lineIndexAfterPackage]
	)
	for _, l := range topLines {
		buf.Write(l)
		buf.WriteByte('\n')
	}

	buf.WriteString("\nimport (\n")

	for _, imp := range file.Imports {
		delete(imports, imp.Path.Value)
		buf.WriteString(imp.Path.Value)
		buf.WriteByte('\n')
	}

	for imp := range imports {
		buf.WriteByte('"')
		buf.WriteString(imp)
		buf.WriteByte('"')
		buf.WriteByte('\n')
	}

	buf.WriteString("\n)")

	var remainderOfFile [][]byte
	if len(file.Imports) > 0 {
		remainderOfFile = lines[fset.Position(file.Imports[len(file.Imports)-1].End()).Line+1:]
	} else {
		remainderOfFile = lines[lineIndexAfterPackage:]
	}
	for _, l := range remainderOfFile {
		buf.Write(l)
		buf.WriteByte('\n')
	}

	return &buf
}

func parseFlags() {
	flag.StringVar(&structName, "struct", "", "the struct to generate")
	flag.StringVar(&source, "src", "", "the source")
	flag.StringVar(&out, "out", "", "the output filepath")
	flag.StringVar(&outPkg, "out-pkg", "", "the output package")
	flag.StringVar(&targetTag, "tag", "", "if provided, the name portion of the provided tag will be used")
	flag.StringVar(&prefix, "prefix", "", "if provided, this value will be prepended to the field's name")
	flag.BoolVar(&export, "export", false, "if true, the generated constants will be exported")
	flag.BoolVar(&includeStructName, "include-struct", false, "if true, the generated constants will be prefixed with the source struct's name")
	flag.BoolVar(&includeUnexported, "unexported", false, "if true, the generated constants will include fields that are not exported on the struct")
	flag.BoolVar(&appendToOut, "append", false, "if true, no package line will be generated and the contents will be appended to out")
	flag.BoolVar(&typed, "typed", false, "if true, a new type with the underlying type of string is created and used for each generated const")
	flag.BoolVar(&genericTyped, "generic", false, "if true, a new generic type is created with the underlying type of string. The concrete type used for the generic argument will be the struct field's type. NOTE: This results in a var block being generated, rather than a const block.")
	flag.Parse()
	flag.Visit(func(f *flag.Flag) {
		if f.Name == "prefix" {
			prefixSet = true
		}
	})

	if structName == "" || source == "" || out == "" || (outPkg == "" && !appendToOut) {
		log.Fatalf("--struct, --src, --out, and --out-pkg must not be empty")
	}
}

func parsePackage(source, structName string) (code []byte, imports map[string]struct{}, err error) {
	structType, s, err := loadStruct(source, structName)
	if err != nil {
		return nil, nil, err
	}
	imports = make(map[string]struct{})
	structPackage := structType.String()[:strings.LastIndexByte(structType.String(), '.')]
	fmt.Println(structPackage)

	var (
		buf                 bytes.Buffer
		maybeCloseConstants = func(i int) {
			if i == s.NumFields()-1 {
				buf.WriteByte(')')
			}
		}
	)

	for i := 0; i < s.NumFields(); i++ {
		field := s.Field(i)
		if !includeUnexported && !field.Exported() {
			maybeCloseConstants(i)
			continue
		}

		tag := s.Tag(i)
		fieldType, baseName, constName, value, imps, err := parseField(structPackage, field, tag)
		if err != nil {
			return nil, nil, err
		}

		if value == "-" { // Handle the case that the field is ignored
			maybeCloseConstants(i)
			continue
		}

		for _, imp := range imps {
			if imp == structPackage {
				continue
			}

			imports[imp] = struct{}{}
		}

		bName := []rune(baseName)
		if export {
			bName[0] = unicode.ToUpper(bName[0])
		} else {
			bName[0] = unicode.ToLower(bName[0])
		}
		baseName = string(bName)

		if buf.Len() == 0 {
			if typed {
				buf.WriteString(fmt.Sprintf("type %s string\n", baseName))
				buf.WriteString(fmt.Sprintf("func (f %s) String() string { return (string)(f) }\n", baseName))
			} else if genericTyped {
				buf.WriteString(fmt.Sprintf("type %s[T any] string\n", baseName))
				buf.WriteString(fmt.Sprintf("func (f %s[T]) String() string { return (string)(f) }\n", baseName))
			}

			buf.WriteString("const (")
		} else {
			buf.WriteByte('\n')
		}

		switch {
		case typed:
			buf.WriteString(fmt.Sprintf("%s %s = %q", constName, baseName, value))
		case genericTyped:
			buf.WriteString(fmt.Sprintf("%s %s[%s] = %q", constName, baseName, fieldType, value))
		default:
			buf.WriteString(fmt.Sprintf("%s = %q", constName, value))
		}
		maybeCloseConstants(i)
	}

	return buf.Bytes(), imports, nil
}

func parseField(structPackage string, field *types.Var, tag string) (fieldType, baseName, constName, value string, imps []string, err error) {
	tags, err := structtag.Parse(tag)
	if err != nil {
		return "", "", "", "", nil, fmt.Errorf("failed to parse struct tags for field %s: %w", field.Name(), err)
	}

	fieldType, imps = parseTypeName(structPackage, field.Type())
	tagNameValue := field.Name()

	if targetTag != "" {
		nameFromTag, err := tags.Get(targetTag)
		if err == nil && len(nameFromTag.Name) > 0 {
			tagNameValue = nameFromTag.Name
		}
	}

	tagName := strings.ToUpper(targetTag)
	if !includeStructName && !export {
		tagName = strings.ToLower(tagName)
	}

	prefix := prefix
	if !prefixSet {
		prefix = structName + tagName
		if !includeStructName {
			prefix = tagName
		}

		prefix += "Field"
	}

	cName := []rune(prefix + field.Name())
	if export {
		cName[0] = unicode.ToUpper(cName[0])
	} else {
		cName[0] = unicode.ToLower(cName[0])
	}

	if prefixSet && !strings.Contains(prefix, "Field") {
		baseName = prefix + "Field"
	} else {
		baseName = prefix
	}

	return fieldType, baseName, string(cName), tagNameValue, imps, nil
}

func loadStruct(source, structName string) (*types.Named, *types.Struct, error) {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
	}

	p, err := packages.Load(cfg, source)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to load struct package: %w", err)
	}

	if len(p) != 1 {
		return nil, nil, fmt.Errorf("expected 1 package for %s, got %d", source, len(p))
	}

	if len(p[0].Errors) > 0 {
		return nil, nil, fmt.Errorf("%v", p[0].Errors)
	}

	scope := p[0].Types.Scope()
	if scope == nil {
		return nil, nil, fmt.Errorf("couldn't find scope: %w", err)

	}

	foundObj := scope.Lookup(structName) // *types.TypeName is returned here
	if foundObj == nil {
		return nil, nil, fmt.Errorf("type %s not found %s: %w", structName, err)
	}

	n, ok := foundObj.Type().(*types.Named)
	if !ok {
		return nil, nil, fmt.Errorf("cannot use type %s, only named struct types are supported", structName)
	}

	s, ok := n.Underlying().(*types.Struct)
	if !ok {
		return nil, nil, fmt.Errorf("cannot use type %s, only named struct types are supported", structName)
	}

	return n, s, nil
}

func parseTypeName(structPackage string, t types.Type) (fieldType string, importPath []string) {
	fmt.Printf("%T: %s \n", t, t.String())
	switch u := t.(type) {
	case *types.Basic:
		return u.Name(), nil
	case *types.Slice:
		sliceElemType, imports := parseTypeName(structPackage, u.Elem())
		return fmt.Sprintf("[]%s", sliceElemType), imports
	case *types.Array:
		arrElemType, imports := parseTypeName(structPackage, u.Elem())
		return fmt.Sprintf("[%d]%s", u.Len(), arrElemType), imports
	case *types.Chan:
		chanElemType, imports := parseTypeName(structPackage, u.Elem())
		switch u.Dir() {
		case types.SendOnly:
			return fmt.Sprintf("chan <- %s", chanElemType), imports
		case types.RecvOnly:
			return fmt.Sprintf("<-chan %s", chanElemType), imports
		case types.SendRecv:
			return fmt.Sprintf("chan %s", chanElemType), imports
		}
	case *types.Pointer:
		elemType, imports := parseTypeName(structPackage, u.Elem())
		return fmt.Sprintf("*%s", elemType), imports
	case *types.Map:
		key, keyImps := parseTypeName(structPackage, u.Key())
		val, valImps := parseTypeName(structPackage, u.Elem())
		return fmt.Sprintf("map[%s]%s", key, val), append(keyImps, valImps...)
	case *types.Signature:
		return parseTypeNameSignature(structPackage, u)
	case *types.TypeParam:
		return "any", nil
	case *types.Alias, *types.Named:
		return parseNamedType(structPackage, u)
	default:
		log.Fatalf("unhandled type %T: %s", t, t)
	}
	return "", nil
}

func parseNamedType(structPackage string, u types.Type) (string, []string) {
	name := u.String()
	dotIndex := strings.LastIndexByte(name, '.')
	pkgPath := name[:dotIndex]
	if pkgPath == structPackage {
		return name[dotIndex+1:], nil
	}

	slashIndex := strings.LastIndexByte(name, '/')
	return name[slashIndex+1:], []string{name[:dotIndex]}
}

func parseTypeNameSignature(structPackage string, u *types.Signature) (string, []string) {
	var (
		sb      strings.Builder
		imports []string
	)

	sb.WriteString("func (")
	for i := 0; i < u.Params().Len(); i++ {
		param := u.Params().At(i)
		paramType, imps := parseTypeName(structPackage, param.Type())
		imports = append(imports, imps...)
		if i > 0 && i < u.Params().Len() {
			sb.WriteByte(',')

		}
		sb.WriteString(paramType)
	}
	sb.WriteByte(')')

	if u.Results().Len() > 1 {
		sb.WriteByte('(')
	}
	for i := 0; i < u.Results().Len(); i++ {
		param := u.Results().At(i)
		paramType, imps := parseTypeName(structPackage, param.Type())
		imports = append(imports, imps...)
		if i > 0 && i < u.Results().Len() {
			sb.WriteByte(',')

		}
		sb.WriteString(paramType)
	}
	if u.Results().Len() > 1 {
		sb.WriteByte(')')
	}

	return sb.String(), imports
}
